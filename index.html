<script>
var JSMathExt = {};

JSMathExt.matrix = function(){
	var rowSize = arguments[0]
		,colSize = arguments[1]
		,data = arguments[2]
		,_size = arguments.length;
		
	this.isSystemEquation = false;
	//creates matrix 
	if( _size == 0 ){
		this.rowSize = rowSize || 3;
		this.colSize = colSize || 3;
		this.data = [[9,1,2],[3,4,5],[6,7,8]] || data;
		
	}else if( _size == 1 ){
		if( !rowSize.length ){
			this.rowSize = this.colSize = rowSize;
			this.data = [];
			var row = [];
			for(var i = 0; i < rowSize; i++ ){
				for(var j = 0; j < rowSize; j++ ){
					row[j] = parseInt(rowSize*Math.random());	
				}
				this.data[i] = row;
				row = [];
			}
		}else{
			var matr = rowSize
				,rows = matr.length
				,cols = (function(){
					var max_col = matr[0].length;
					for(var i = 0; i<matr.length; i++){
						if(max_col < matr[i].length)max_col = matr[i].length;
					}
					return max_col;
				})(matr)
				,row = [];
				
			this.data = [];
			this.rowSize = rows;
			this.colSize = cols;	
			
			for(var i=0; i < rows; i++){
				for(var j=0; j < cols; j++){
					row[j] = (matr[i][j] || 0);
				}
				this.data[i] = row;
				row = [];
			}
		}
		
	}else if( _size == 2 ){
		if( !rowSize.length ){
			this.rowSize = rowSize;
			this.colSize = colSize;
			this.data = [];
			var row = [];
			for(var i = 0; i < rowSize; i++ ){
				for(var j = 0; j < colSize; j++ ){
					row[j] = parseInt(rowSize*colSize*Math.random());	
				}
				this.data[i] = row;
				row = [];
			}
		}else{
			//here matrix presents systems of linear equations
			this.isSystemEquation = true;
			var matr = rowSize
				,rows = matr.length
				,cols = (function(){
					var max_col = matr[0].length;
					for(var i = 0; i<matr.length; i++){
						if(max_col < matr[i].length)max_col = matr[i].length;
					}
					return max_col;
				})(matr)
				,row = [];
				
			this.data = [];
			this.rowSize = rows;
			this.colSize = cols;	
			
			for(var i=0; i < rows; i++){
				for(var j=0; j < cols; j++){
					row[j] = (matr[i][j] || 0);
				}
				this.data[i] = row;
				row = [];
			}
			
			if( colSize.length ){
				console.log(colSize);
			}else{
			
			}
			
		}
	
	}else{
		this.rowSize = rowSize ;
		this.colSize = colSize ;
		this.data = []; //data;
		
		var count = (data.join().split(",")).length
			,mustBe = rowSize*colSize;
		
		if(count < mustBe){
			throw("There are too little elements "+mustBe+" , "+count);
		}else if(count > mustBe){
			throw("There are too more elements "+mustBe+" , "+count);
		}else{
			var row = [];
			console.log(data);
				
			for(var i = 0; i < rowSize; i++ ){
				for(var j = 0; j < colSize; j++ ){
					row[j] = parseInt( data.shift() );	
				}
			this.data[i] = row;
			row = [];
			}
		}
	};
	
	//print matrix to web console and return matrix as string
	this.print = function(){
		var me = this , str = "";
		
		if( me.data.length == 0 )return null;
		for( var i=0 ; i < me.rowSize; i++ ){
			for( var j=0; j < me.colSize; j++ )
				str += me.data[i][j]+" ";
			str += "\n";
		}
		return str;
	};
	
	//
	this.toString = function(){
		return this.print();
	}
	
	//adds row
	this.addRow = function(row,place){
		var place = parseInt(arguments[1])
			,row = arguments[0]
			,me = this;
		try{
			if( !(row instanceof Array) ){
				throw("Row is not array");
			}
		}catch(e){
			row = [];
		}finally{
			if(row.length < this.rowSize){
				row = this._stretchVectorBy( row,this.rowSize);
			}
			
			if( place ){
				this.data.splice( place,0,row );
				this.rowSize++;
			}else{
				this.data.push( row );
				this.rowSize++;
			}
		}
	};
	
	//adds column
	this.addCol = function(col,place){
		var place = parseInt(arguments[1])
			,col = arguments[0]
			,me = this;
		
		try{
			if( !(col instanceof Array) ){
				throw("Column is not array");
			}
		}catch(e){
			col = new Array();
		}finally{
			if(col.length < me.colSize){
				col = me._stretchVectorBy( col,me.colSize);
			}
			
			if( place ){
				me.transpon();
				me.data.splice( place,0,col );
				me.rowSize++;
			}else{
				me.transpon();
				me.data.push( col );
				//me.colSize++;
				me.rowSize++;
			}
			me.transpon();
		}
	};
	
	//remove column
	this.removeColAt = function(){
		
		var place = parseInt( arguments[0] )
			,columns = []
			,me = this;
				
		me.transpon();	
		if( place || place == 0 ){
			me.data.splice( place,1 );
		}else{
			me.data.splice( me.colSize-1,1 );
		}
		me.rowSize--;
		me.transpon();	
	};
	
	//remove row
	this.removeRowAt = function(){
		var place = parseInt( arguments[0] )
			,columns = []
			,me = this;
				
		if( place ){
			me.data.splice( place,1 );
		}else{
			me.data.splice( me.rowSize-1,1 );
		}
		me.rowSize--;
	};
	
	//gets i-th row as array
	this.getRowAt = function(k){
		var ar = []
			,k = (function(numb){
				var k = numb;
				if(k-k == 0)return k;
				console.log('Error in getRowAt: argument is not number ');
				return 0;
			})(arguments[0]);
		
		for(var i = 0; i < this.colSize; i++){
			ar[i] = this.data[k][i];
		}
		return ar;
	};
	
	//change N-th row 
	this.replaceRowAt = function(row,k){
		for( var i = 0; i < this.colSize; i++ ){
			this.data[k][i] = row[i];
		}
	}  
	
	//gets i-th column as array
	this.getColAt = function(k){
		var ar = []
			,k = (function(numb){
				var k = numb;
				if(k-k == 0)return k;
				console.log('Error in getColAt: argument is not number ');
				return 0;
			})(arguments[0]);
		
		for( var i = 0; i < this.rowSize; i++ ){
			ar[i] = this.data[i][k];
		}
		
		return ar;
	};
	
	//replace i-th column 
	this.replaceColAt = function(col,k){
		for( var i = 0; i < this.rowSize; i++ ){
			this.data[i][k] = col[i];
		}
	};
	
	//scalar value of two vectors
	this.scalar = function(m1,m2){
		var val = 0;
		for(var i = 0; i < m1.length; i++)val +=(m1[i]*m2[i]);
		return val;
	};
	
	//check matrix to be N x N
	this.isQuad = function(){
		if(this.colSize == this.rowSize)return true;
		return false;
	};
	
	//inner function return multiplication of dimensions of matrix N*M
	//it is used (after) in conjunction with isQuad
	this._prodSize = function(){
		return this.colSize * this.rowSize;
	};
	
	//inner function stretch row or column to relevant matrix size by argument or 0
	this._stretchVectorBy = function(){
		var vector = arguments[0]
			,size = arguments[1]
			,stub = arguments[2] || [];
		for(var i = 0;i<size;i++)vector.push( (stub[i] || 0) );
		return vector;
	};
	
	//multiply matrix to matrix or number, return resulting one
	this.multiply = function(){
		var matr = arguments[0]//ohter matrix
			,me = this//this matrix 
			,res = new matrix(me.colSize,me.colSize);

		if( (matr instanceof matrix) ){
			if( me.isQuad() && matr.isQuad() ){
				//if matrixes are quadratic then check them to be equal size
				if( me._prodSize() == matr._prodSize() ){
					for(var i = 0; i < me.rowSize; i++){
						for(var j = 0; j < me.colSize; j++){
							res.data[i][j] = me.scalar(me.getRowAt(i),matr.getColAt(j));
						}
					}
					
					return res;
				}else{
					throw("Matrixes have not equal size");
				}
			}else{
				throw("Matrix is not quadratic ");
			}
			
		}else{
			var number = parseInt(matr);
			for(var i = 0; i < me.rowSize; i++){
				for(var j = 0; j < me.colSize; j++){
					me.data[i][j] *= number;
				}
			}
		}
		return me;
	};
	
	//gets submatrix 
	this.sub = function(){
		var data = []
			,matr = null
			,n = parseInt(arguments[0]);
		
		for(var i = 0; i < this.rowSize; i++){
			for( var j =0; j < this.colSize; j++){
				if(!n || n == 0){
					if(i != 0 && j!= 0) data.push(this.data[i][j]);
				}else{
					if( i >= n && j >=n ) data.push(this.data[i][j]);
				}
			}
		} 
		
		matr = new JSMathExt.matrix(this.rowSize-n,this.colSize-n,data);
		return matr;
	};
	
	//transponiren das matrix
	this.transpon = function(){
		var me = this
			,columns = []
			,rows = me.rowSize
			,cols = me.colSize;
		console.log(rows+' '+cols);
		for( var i=0; i < cols; i++ ){
			columns.push( me.getColAt(i) );
		}
		me.data = columns;
		me.rowSize = cols;
		me.colSize = rows;
	};
	
};

var M = JSMathExt.matrix ;
if(Math)Math.matrix = M;
</script>
